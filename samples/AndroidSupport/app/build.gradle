import java.util.regex.Matcher
import java.util.regex.Pattern

apply plugin: 'com.android.application'

android {
    compileSdkVersion 26
    buildToolsVersion "26.0.2"
    defaultConfig {
        applicationId "org.qiyi.support"
        minSdkVersion 14
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    // Android Support Library
    compile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
    //compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
}


afterEvaluate {
    android.applicationVariants.all { variant ->

        println "variant name:${variant.name}"

        File publicXml = project.file("public.xml")

        def scope = variant.getVariantData().getScope()
        String mergeTaskName = scope.getMergeResourcesTask().name
        Task mergeResTask = tasks.getByName(mergeTaskName)

        mergeResTask.doLast {
            copy {
                int i=0
                from(android.sourceSets.main.res.srcDirs) {
                    include 'values/public.xml'
                    rename 'public.xml', (i++ == 0? "public.xml": "public_${i}.xml")
                }

                into(mergeResTask.outputDir)
            }

            if (!publicXml.exists()) {
                println "publicXml file not exist"
                return
            }

            File mergeResDir = new File(mergeResTask.outputDir, "values")
            println "mergeResDir: ${mergeResDir}"
            // 生成ids.xml
            File idsFile = project.file("ids.xml")
            if (idsFile.exists()) {
                idsFile.delete()
            }

            idsFile.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
            idsFile.append("\n")
            idsFile.append("<resources>")
            idsFile.append("\n")

            File valuesFile = new File(mergeResDir, "values.xml")
            Set<String> existIdItems = new HashSet<String>()
            if (valuesFile.exists()) {
                //记录在values.xml中存在的id定义
                def valuesNodes = new XmlParser().parse(valuesFile)
                valuesNodes.each {
                    if ("id".equalsIgnoreCase("${it.@type}")) {
                        existIdItems.add("${it.@name}")
                    }
                }
            }

            def publicXMLNodes = new XmlParser().parse(publicXml)
            Pattern drawableGeneratePattern = Pattern.compile('^(.*?_)([0-9]{0,})$')
            publicXMLNodes.each {
                //获取public.xml中定义的id类型item
                if ("id".equalsIgnoreCase("${it.@type}")) {
                    //如果在values.xml中没有定义，则添加到ids.xml中
                    //如果已经在values.xml中定义，则忽略它
                    if (!existIdItems.contains("${it.@name}")) {
                        idsFile.append("\t<item type=\"id\" name=\"${it.@name}\" />\n")
                    } else {
                        project.logger.error "already exist id item ${it.@name}, ignore it"
                    }
                } else if ("drawable".equalsIgnoreCase("${it.@type}")) {
                    //以'_数字'结尾的drawable资源，此类资源是aapt编译时生成的nested资源，如avd_hide_password_1, avd_hide_password_2
                    //但是可能会有其他资源掺杂，如abc_btn_check_to_on_mtrl_000, abc_btn_check_to_on_mtrl_015
                    //为了将此类资源过滤掉，将正则匹配到的数字转成int，对比原始数字部分匹配字符串，如果一致，则是aapt生成
                    //重要：为了避免此类nested资源生成顺序发生改变，应该禁止修改此类资源
                    Matcher matcher = drawableGeneratePattern.matcher(it.@name)
                    if (matcher.matches() && matcher.groupCount() == 2) {
                        String number = matcher.group(2)
                        if (number.equalsIgnoreCase(Integer.parseInt(number).toString())) {
                            //project.logger.info "[${PREFIX}] declared drawable resource ${it.@name} which is generated by aapt. like use '<aapt:attr name=\"android:drawable\">'"
                            idsFile.append("\t<item type=\"drawable\" name=\"${it.@name}\" />\n")
                        }
                    }
                }
            }

            idsFile.append("</resources>")
        }

        if (!publicXml.exists()) {
            // 生成public.xml
            android.aaptOptions.additionalParameters("-P", "${publicXml}")
        }
    }
}


task reBuildPublicXml(dependsOn: ['assembleDebug']) << {
    File publicXml = project.file("public.xml")
    File publicNewXml = project.file(project.hasProperty("public_name") ? project.property("public_name") : "public_n.xml")
    if (publicNewXml.exists()) {
        publicNewXml.delete()
    }
    publicNewXml.createNewFile()
    def writer = publicNewXml.newPrintWriter()

    if (publicXml.exists()) {
        publicXml.eachLine { line ->
            String tmp = line.trim()
            println "public.xml line ${line}"
//            if (tmp.isEmpty()) {
//                return
//            }

            if ((tmp.startsWith("<!--") || tmp.endsWith("-->"))
                && tmp.contains("Declared at")) {
                // comment line
                return
            }
            println "write to new public.xml ${line}"
            writer.write(line)
            writer.write("\n")
        }
        writer.close()
    }
}

task JarSupport(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) {
    archiveName = "android_support_${ANDROID_SUPPORT_VERSION}.jar"
    destinationDir = file('build/libs')
    from project.configurations.compile.findAll {
        def path = it.getAbsolutePath()
        (path.contains("support") || path.contains("arch")) &&
                (path.endsWith(".jar") || path.endsWith(".aar"))
    }.collect {
        if (it.getName().endsWith('.jar')) {
            project.zipTree(it)
        } else if (it.getName().endsWith('.aar')) {

            def aarDir = project.file("${project.buildDir}/aar")
            if (!aarDir.exists()) {
                aarDir.mkdirs()
            }

            def aarPath = it.getPath()
            def jarName = it.getName().replace('.aar', '.jar')
            copy {
                from zipTree(aarPath)
                into aarDir
                include('**/*.jar')
                rename 'classes.jar', jarName
            }
            project.zipTree("${aarDir.absolutePath}/$jarName")
        }
    }
    include("android/support/**/*.class")
    include("android/arch/**/*.class")
}
